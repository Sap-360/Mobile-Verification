var crypto = require("crypto");
var q      = require("q");
var fs     = require("fs");
var bcrypt = require("bcrypt");

var autho = function(){
  this.algo      = "aes256";
  this.cipherIn  = false;
  this.cipherOut = false;
  this.certPath  = false;
  return this;
};

autho.prototype.encryptPassword = function(password){
  var d = q.defer();
  bcrypt.genSalt(10, function(err, salt) {
    bcrypt.hash(password, salt, function(err, hash){
      d.resolve(hash);
    });
  });
  return d.promise;
};

autho.prototype.comparePassword = function(password, hash){
  var d = q.defer();
  bcrypt.compare(password, hash, function(err, res) {
    if(res){
      d.resolve();
    } else {
      d.reject();
    }
  });
  return d.promise;
};

autho.prototype.encrypt = function(str, password){
  if(password){
    this.cipherIn = crypto.createCipher(this.algo, password);
    try {
      return this.cipherIn.update(str, "utf8", "hex") + this.cipherIn.final("hex");
    } catch(e){
      return false;
    }
  }
  else {
    var d = q.defer();
    var s = this;
    this._verify().then(function(password){
      try {
        s.cipherIn = crypto.createCipher(s.algo, password);
        d.resolve(s.cipherIn.update(str, "utf8", "hex") + s.cipherIn.final("hex"));
      } catch(e){
        d.reject("Unable to encrypt provided string.");
      }
    },
    d.reject);
    return d.promise;
  }
};

autho.prototype.decrypt = function(str, password){
  if(password){
    try {
      this.cipherOut = crypto.createDecipher(this.algo, password);
      return this.cipherOut.update(str, 'hex', 'utf8') + this.cipherOut.final('utf8');
    } catch(e){
      return false;
    }
  }
  else {
    var d = q.defer();
    var s = this;
    this._verify().then(function(password){
      try {
        s.cipherOut = crypto.createDecipher(s.algo, password);
        d.resolve(s.cipherOut.update(str, 'hex', 'utf8') + s.cipherOut.final('utf8'));
      } catch(e){
        d.reject("Invalid encrypted string provided.");
      }
    });
    return d.promise;
  }
};

autho.prototype._verify = function(){
  var d = q.defer();
  fs.readFile(this.certPath, "utf8", function(err,cert){
    if(err){
      d.reject("Certificate path file does not exist.");
    } else {
      d.resolve(cert);
    }
  });
  return d.promise;
};

module.exports = new autho();
